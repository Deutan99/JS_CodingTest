// # **[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/?envType=study-plan&id=data-structure-i)**

// 해당 코드는 TreeNode이라는 객체를 정의하고, 이진 트리 노드의 값을 저장하는 val 속성과 좌우 자식 노드를 저장하는 left, right 속성을 가지고 있습니다. val, left, right 속성의 값이 undefined인 경우 null로 초기화되도록 설정되어 있습니다.


var inorderTraversal = function(root) {
    const result = []; // 결과값 배열 초기화

    const traversal = (node, result) => { // 재귀 함수 정의
        if (!node) return; // 노드가 null이면 종료w

        traversal(node.left, result); // 왼쪽 자식 노드로 이동하며 탐색(왼쪽 자식 노드 재귀 호출)
        result.push(node.val); // 현재 노드 값을 결과값 배열에 추가
        traversal(node.right, result); // 오른쪽 자식 노드로 이동하며 탐색(오른쪽 자식 노드 재귀 호출)
    }

    traversal(root, result); // 재귀 함수 실행
    return result; // 결과값 반환
};


// 1. **`inorderTraversal`** 함수는 이진 트리의 루트 노드를 인자로 받는다.
// 2. **`result`** 배열은 함수 내부에서 사용되는 결과값 배열로 초기화 한다.
// 3. **`traversal`** 함수는 노드와 결과값 배열을 인자로 받아 재귀적으로 순회하며 결과값을 생성하는 함수이다.
// 4. 먼저 **`node`**가 null인 경우 종료하며, 그렇지 않으면 왼쪽 자식 노드로 이동하면서 탐색을 수행한다.(왼쪽 자식 노드 재귀 호출)
// 5. 왼쪽 자식 노드를 모두 탐색한 후, 현재 노드의 값을 결과값 배열에 추가한다.
// 6. 마지막으로 오른쪽 자식 노드로 이동하면서 탐색을 수행한다.
// 7. **`traversal`** 함수를 **`root`** 노드와 결과값 배열을 인자로 호출하여 재귀적으로 탐색을 수행한다.
// 8. 결과값 배열을 반환한다.


var inorderTraversal = function(root) {
	const result = []; // 결과를 저장할 배열을 선언합니다.
	const stack = []; // 노드를 저장할 스택을 선언합니다.
	
	let node = root; // 루트 노드부터 시작합니다.
	
	while (node || stack.length > 0) { // 현재 노드가 null이 아니거나 스택에 노드가 남아있을 때까지 반복합니다.
	    while (node) { // 현재 노드가 null이 아니면서
	        stack.push(node); // 현재 노드를 스택에 추가합니다.
	        node = node.left; // 현재 노드를 왼쪽 자식 노드로 이동합니다.
	    }
	    node = stack.pop(); // 스택에서 가장 최근에 추가된 노드를 꺼냅니다.
	    result.push(node.val); // 꺼낸 노드의 값을 결과 배열에 추가합니다.
	    node = node.right; // 꺼낸 노드의 오른쪽 자식 노드로 이동합니다.
	}

	return result; // 결과 배열을 반환합니다.
}

// 해당 코드는 이진트리의 중위순회(inorder traversal)를 스택을 이용하여 구현한 코드입니다.

// 이진트리의 중위순회는 왼쪽 서브트리, 루트 노드, 오른쪽 서브트리 순으로 노드를 방문하는 순회 방식입니다.

// 이 코드는 먼저 결과를 저장할 배열 **`result`**와 방문할 노드를 저장할 스택 **`stack`**을 초기화합니다. 그리고 루트 노드를 시작으로 하여 왼쪽 서브트리를 순회하면서 노드를 스택에 추가합니다.

// 그리고 스택에서 노드를 pop하여 해당 노드를 결과 배열에 추가하고, 오른쪽 자식 노드를 방문하기 위해 다음 노드로 이동합니다.

// 이러한 과정을 스택이 빌 때까지 반복합니다. 이러한 방법을 통해 이진트리의 중위순회를 스택을 이용하여 구현할 수 있습니다.

// 즉, 이 코드는 스택 자료구조를 이용하여 이진트리를 중위순회하는 방법을 구현한 코드입니다. 이해하기 쉬운 방법으로 설명하자면, 이 코드는 왼쪽 서브트리를 먼저 순회하고, 그 다음에 현재 노드를 결과 배열에 추가하며, 오른쪽 서브트리를 순회합니다. 이러한 방식을 스택을 이용하여 구현한 것입니다.

// ---

// 코드의 첫째 줄에서는 결과값을 저장할 배열 **`result`**를 선언하고, 둘째 줄에서는 스택 **`stack`**을 선언합니다.

// 세번째 줄에서는 루트 노드를 가리키는 변수 **`node`**를 초기화합니다.

// while 루프의 조건 **`node || stack.length > 0`**은 **`node`**가 존재하거나, **`stack`**에 아직 남아있는 노드가 있을 때까지 반복됩니다.

// 안쪽 while 루프에서는 현재 노드를 **`stack`**에 추가한 후, 왼쪽 자식 노드로 이동합니다. 왼쪽 자식 노드가 존재하지 않을 때까지 **`stack`**에 노드를 추가하고 계속 왼쪽 자식 노드로 이동합니다.

// 밖쪽 while 루프에서는 **`stack`**에서 마지막에 추가된 노드를 가져옵니다. 이 노드의 값을 **`result`**에 추가한 후, 오른쪽 자식 노드로 이동합니다.

// 이러한 과정을 반복하다보면, 이진 트리의 중위 순회 결과인 **`result`** 배열이 완성됩니다.